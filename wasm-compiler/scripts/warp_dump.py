# Copyright (C) 2025 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)
# SPDX-License-Identifier: Apache-2.0
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""dump jit code generated by warp"""

import argparse
import os
import aarch64_vb_warp
import aarch64_active_vb_warp
import x86_64_vb_warp
import x86_64_active_vb_warp
import tricore_vb_warp
import platform
import sys
from helper import wasm_utils, dwarf
import tempfile
import subprocess

parser = argparse.ArgumentParser(description="disassembly jit code generated by warp")
parser.add_argument("--module", "-m", help="path to the wasm file", required=True)
parser.add_argument("--import", nargs=3, action="append")
parser.add_argument("--debug", action="store_true")
parser.add_argument("--print-debug-map", action="store_true")
parser.add_argument("--print-dwo", action="store_true")
parser.add_argument(
    "--target",
    choices=["x86_64", "aarch64", "tricore"],
    help="target architecture (default: local architecture)",
)
parser.add_argument(
    "--mode",
    choices=["passive", "active"],
    help="compilation mode, passive or active (default: passive)",
)

args = parser.parse_args()
print(args)

imports = args.__dict__["import"]


# Determine the local architecture for default target
def get_local_architecture():
    machine = platform.machine().lower()
    if machine in ["x86_64", "amd64", "x64"]:
        return "x86_64"
    elif machine in ["arm64", "aarch64", "armv8"]:
        return "aarch64"
    else:
        print(f"Warning: Unknown machine architecture: {machine}")
        sys.exit(1)


# Select target architecture
target = args.target if args.target else get_local_architecture()
# Select mode (default to passive)
mode = args.mode if args.mode else "passive"

# Select the appropriate warp module
if target == "x86_64":
    vb_warp = x86_64_active_vb_warp if mode == "active" else x86_64_vb_warp
elif target == "aarch64":
    vb_warp = aarch64_active_vb_warp if mode == "active" else aarch64_vb_warp
elif target == "tricore":
    if mode == "passive":
        print("Error: tricore doesn't support passive mode")
        sys.exit(1)
    vb_warp = tricore_vb_warp
else:
    raise ValueError(f"Unsupported target: {target}")

print(vb_warp.get_configuration())

compiler = vb_warp.Compiler()
compiler.enable_log(True)
if args.debug:
    compiler.enable_debug_mode(True)
if imports:
    for [module_name, func_name, signature] in imports:
        compiler.register_api(module_name, func_name, signature)

compiler.enable_dwarf(True)
module = compiler.compile(wasm_utils.load_wasm_or_wat(args.module))
print(compiler.disassemble_module(module))


if args.print_debug_map:
    assert args.debug
    print(compiler.disassemble_debug_map(module))
if args.print_dwo:
    dwo_info = dwarf.dump_dwo(compiler.get_dwarf_object())
    print(dwo_info)
